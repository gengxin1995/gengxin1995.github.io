[{"title":"Candy Sharing Game","date":"2017-04-25T10:08:20.000Z","path":"2017/04/25/刷题-Candy Sharing Game/","text":"题目地址：牛客网-Candy Sharing Game 题目描述：A number of students sit in a circle facing their teacher in the center. Each student initially has an number of pieces of candy. When the teacher blows a whistle, each student simultaneously gives half of his or her candy to the neighbor on the right. Any student, who ends up with an odd number of pieces of candy, is given another piece by the teacher. The game ends when all students have the same number of pieces of candy. Write a program which determines the number of times the teacher blows the whistle and the final number of pieces of candy for each student from the amount of candy each child starts with.输入描述：The input may describe more than one game. For each game, the input begins with the number N of students,followed by N candy counts for the children counter-clockwise around the circle. The input ends with a student count of 0. Each input number is on a line by itself. 输出描述：For each game, output the number of rounds of the game followed by the amount of candy each child ends up with,both on one line.The game ends in a finite number of steps because: The maximum candy count can never increase. The minimum candy count can never decrease. No one with more than the minimum amount will ever decrease to the minimum. If the maximum and minimum candy count are not the same, at least one student with the minimum amount must have their count increase 输入例子：6362222211222018161412108642424680 输出例子：15 1417 224 8 解题思路：每个人将自己糖果的一般分给下一个人，再从上一个人处得到他糖果的一半，如果糖果数为奇数，就从老师那里得到一颗糖果。每个人的糖果数都相等则停止。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext())&#123; int n = in.nextInt(); if(n == 0)&#123; break; &#125; int[] arr = new int[n]; for(int i = 0; i &lt; n; i++)&#123; arr[i] = in.nextInt(); &#125; int count = 0; int temp1,temp2; int i; while (true)&#123; for(i = 1; i &lt; n; i++) if(arr[i] != arr[i-1]) break; if(i &gt;= n) break; count++; temp2 = arr[0]; for(i = 1; i &lt; n; i++)&#123; temp1 = arr[i]; arr[i] -= arr[i] / 2; arr[i] += temp2 / 2; temp2 = temp1; &#125; arr[0] -= arr[0] / 2; arr[0] += temp2 / 2; for(i = 0; i &lt; n; i++)&#123; if(arr[i]%2 == 1) arr[i]++; &#125; &#125; System.out.println(count + \" \" + arr[0]); &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://www.sillydeer.com/tags/java/"},{"name":"考研机试","slug":"考研机试","permalink":"http://www.sillydeer.com/tags/考研机试/"}]},{"title":"Freckles","date":"2017-04-25T10:06:24.000Z","path":"2017/04/25/刷题-Freckles/","text":"题目地址：牛客网-Freckles 题目描述：In an episode of the Dick Van Dyke show, little Richie connects the freckles on his Dad’s back to form a picture of the Liberty Bell. Alas, one of the freckles turns out to be a scar, so his Ripley’s engagement falls through.Consider Dick’s back to be a plane with freckles at various (x,y) locations. Your job is to tell Richie how to connect the dots so as to minimize the amount of ink used. Richie connects the dots by drawing straight lines between pairs, possibly lifting the pen between lines. When Richie is done there must be a sequence of connected lines from any freckle to any other freckle.输入描述：The first line contains 0 &lt; n &lt;= 100, the number of freckles on Dick’s back. For each freckle, a line follows; each following line contains two real numbers indicating the (x,y) coordinates of the freckle. 输出描述：Your program prints a single real number to two decimal places: the minimum total length of ink lines that can connect all the freckles. 输入例子：31.0 1.02.0 2.02.0 4.0 输出例子：3.41 解题思路：最小生成树问题 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext())&#123; int n = in.nextInt(); Point[] pArr = new Point[n]; for(int i =0; i &lt; n; i++)&#123; pArr[i] = new Point(in.nextDouble(),in.nextDouble()); &#125; System.out.printf(\"%.2f\",process(pArr,n)); &#125; &#125; private static Object process(Point[] pArr, int len) &#123; double[][] cost = new double[len][len]; for(int i = 0; i &lt; len; i++)&#123; for(int j = 0; j &lt; len; j++)&#123; double q = Math.sqrt((pArr[i].x-pArr[j].x)*(pArr[i].x-pArr[j].x)+(pArr[i].y-pArr[j].y)*(pArr[i].y-pArr[j].y)); cost[i][j] = q; &#125; &#125; double sum = createPrimeTree(cost,len); return sum; &#125; private static double createPrimeTree(double[][] cost, int len) &#123; int[] used = new int[len]; double[] minCost = new double[len]; for(int i = 0; i &lt; len; i++)&#123; used[i] = 0; minCost[i] = Double.MAX_VALUE; &#125; minCost[0] = 0.0; double sum = 0.0; while (true)&#123; int v = -1; for(int i = 0; i &lt; len; i++)&#123; if(used[i] == 0 &amp;&amp; (v == -1 || minCost[i] &lt; minCost[v])) v = i; &#125; if(v == -1) break; used[v] = 1; sum += minCost[v]; for(int i = 0; i &lt; len; i++)&#123; minCost[i] = Math.min(minCost[i],cost[v][i]); &#125; &#125; return sum; &#125;&#125;class Point&#123; double x; double y; public Point(double x,double y)&#123; this.x = x; this.y = y; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://www.sillydeer.com/tags/java/"},{"name":"考研机试","slug":"考研机试","permalink":"http://www.sillydeer.com/tags/考研机试/"}]},{"title":"全排列","date":"2017-04-25T10:05:56.000Z","path":"2017/04/25/刷题-全排列/","text":"题目地址：牛客网-全排列 题目描述：给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 我们假设对于小写字母有’a’ \\&lt; ‘b’ \\&lt; … \\&lt; ‘y’ \\&lt; ‘z’，而且给定的字符串中的字母已经按照从小到大的顺序排列。输入描述：输入只有一行，是一个由不同的小写字母组成的字符串，已知字符串的长度在1到6之间。 输出描述：输出这个字符串的所有排列方式，每行一个排列。要求字母序比较小的排列在前面。字母序如下定义：已知S = s1s2…sk , T = t1t2…tk，则S &lt; T 等价于，存在p (1 &lt;= p &lt;= k)，使得s1 = t1, s2 = t2, …, sp - 1 = tp - 1, sp &lt; tp成立。每组样例输出结束后要再输出一个回车。 输入例子：abc 输出例子：abcacbbacbcacabcba 代码如下：123456789101112131415161718192021222324252627282930313233import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext())&#123; String str = in.next(); char[] arr = str.toCharArray(); ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); Permutation(arr,0,arr.length-1,list); Collections.sort(list); for (int i = 0; i &lt;list.size(); i++) &#123; System.out.println(list.get(i)); &#125; System.out.println(); &#125; &#125; private static void Permutation(char[] arr, int start, int end,ArrayList list) &#123; if(start == end)&#123; list.add(String.valueOf(arr)); &#125;else &#123; for(int i = start; i &lt;=end; i++)&#123; char temp = arr[start]; arr[start] = arr[i]; arr[i] = temp; Permutation(arr,start+1,end,list); temp = arr[start]; arr[start] = arr[i]; arr[i] = temp; &#125; &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://www.sillydeer.com/tags/java/"},{"name":"考研机试","slug":"考研机试","permalink":"http://www.sillydeer.com/tags/考研机试/"}]},{"title":"玛雅人的密码","date":"2017-04-24T13:29:49.000Z","path":"2017/04/24/刷题-玛雅人的密码/","text":"题目地址：牛客网-玛雅人的密码 题目描述：玛雅人有一种密码，如果字符串中出现连续的2012四个数字就能解开密码。给一个长度为N的字符串，该字符串中只含有0,1,2三种数字，问这个字符串要移位几次才能解开密码，每次只能移动相邻的两个数字。例如02120经过一次移位，可以得到20120,01220,02210,02102，其中20120符合要求，因此输出为1.如果无论移位多少次都解不开密码，输出-1。输入描述：输入包含多组测试数据，每组测试数据由两行组成。第一行为一个整数N，代表字符串的长度（2&lt;=N&lt;=13）。第二行为一个仅由0、1、2组成的，长度为N的字符串。 输出描述：对于每组测试数据，若可以解出密码，输出最少的移位次数；否则输出-1。 输入例子：502120 输出例子：1 解题思路：使用广度优先搜索，将最初的字符串放入队列中，每次从队头弹出字符串后，就将该字符串经过一次移位后得到的字符串放入队尾，用HashMap来存储新得到的字符串和该字符串相对于原始字符串的移位次数。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;public class Main &#123; static int size; static class str_step&#123; String str; int step; str_step(String str, int step)&#123; this.str = str; this.step = step; &#125; &#125; static int BFS(String str, int length)&#123; if(length &lt; 4) return -1; HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); //用来存储字符串和相对于原始字符串的移位次数 LinkedList&lt;str_step&gt; queue = new LinkedList&lt;str_step&gt;(); map.put(str,size++); queue.add(new str_step(str,0)); while (!queue.isEmpty())&#123; str_step st = queue.getFirst(); queue.removeFirst(); if(st.str.contains(\"2012\"))&#123; return st.step; &#125; for(int i = 0; i &lt; st.str.length()-1; i++)&#123; char[] tempstr = st.str.toCharArray(); char temp = tempstr[i]; tempstr[i] = tempstr[i+1]; tempstr[i+1] = temp; String strtemp = String.valueOf(tempstr); if(!map.containsKey(strtemp))&#123; queue.add(new str_step(strtemp,st.step+1)); map.put(strtemp,size++); &#125; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext())&#123; int n = in.nextInt(); String str = in.next(); size = 0; System.out.println(BFS(str,n)); &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://www.sillydeer.com/tags/java/"},{"name":"考研机试","slug":"考研机试","permalink":"http://www.sillydeer.com/tags/考研机试/"},{"name":"BFS","slug":"BFS","permalink":"http://www.sillydeer.com/tags/BFS/"}]},{"title":"I Wanna Go Home","date":"2017-04-23T14:30:30.000Z","path":"2017/04/23/刷题-I-Wanna-Go-Home/","text":"题目地址：牛客网-I Wanna Go Home 题目描述：The country is facing a terrible civil war—-cities in the country are divided into two parts supporting different leaders. As a merchant, Mr. M does not pay attention to politics but he actually knows the severe situation, and your task is to help him reach home as soon as possible.“For the sake of safety,”, said Mr.M, “your route should contain at most 1 road which connects two cities of different camp.”Would you please tell Mr. M at least how long will it take to reach his sweet home?输入描述：The input contains multiple test cases.The first line of each case is an integer N (2&lt;=N&lt;=600), representing the number of cities in the country.The second line contains one integer M (0&lt;=M&lt;=10000), which is the number of roads.The following M lines are the information of the roads. Each line contains three integers A, B and T, which means the road between city A and city B will cost time T. T is in the range of [1,500].Next part contains N integers, which are either 1 or 2. The i-th integer shows the supporting leader of city i.To simplify the problem, we assume that Mr. M starts from city 1 and his target is city 2. City 1 always supports leader 1 while city 2 is at the same side of leader 2.Note that all roads are bidirectional and there is at most 1 road between two cities.Input is ended with a case of N=0. 输出描述：For each test case, output one integer representing the minimum time to reach home.If it is impossible to reach home according to Mr. M’s demands, output -1 instead. 输入例子：211 2 1001 2331 2 1001 3 402 3 501 2 1553 1 2005 3 1502 5 1604 3 1704 2 1701 2 2 2 10 输出例子：10090540 解题思路：首先对输入数据构建邻接矩阵，注意可能会出现两点之间有多组数据，存储距离最小的一组。然后去除从country2到country1的值。最后用Dijkstra算法求最短路径。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.*;public class Main &#123; public static void main(String[] args) &#123; int max = 10000; Scanner in = new Scanner(System.in); while (in.hasNext())&#123; int n = in.nextInt(); if(n == 0) break; int m = in.nextInt(); int[][] arr = new int[n+1][n+1]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1;j &lt;= n; j ++)&#123; arr[i][j] = max; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); if(c &lt; arr[a][b])&#123; arr[a][b] = c; arr[b][a] = c; &#125; &#125; int[] cls = new int[n+1]; for(int i = 1; i &lt;= n; i++)&#123; cls[i] = in.nextInt(); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1;j &lt;= n; j ++)&#123; if(cls[i] == 2 &amp;&amp; cls[j] == 1)&#123; arr[i][j] = max; &#125; &#125; &#125; boolean[] flag = new boolean[n+1]; int[] dis = new int[n+1]; dis[1] = 0; flag[1] = true; int start = 1; int end = 2; for(int i = 1; i &lt;= n; i++)&#123; int k = -1; int min = 10000; for(int j = 1;j &lt;= n; j++)&#123; if(flag[j] == false &amp;&amp; arr[start][j] &lt; min)&#123; min = arr[start][j]; k = j; &#125; &#125; if(k != -1)&#123; dis[k] = min; flag[k] = true; for(int j = 1; j &lt;= n; j++)&#123; if(flag[j] == false &amp;&amp; arr[start][k] + arr[k][j] &lt; arr[start][j])&#123; arr[start][j] = arr[start][k] + arr[k][j]; &#125; &#125; &#125; &#125; if(dis[end] != 0)&#123; System.out.println(dis[end]); &#125;else &#123; System.out.println(-1); &#125; &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://www.sillydeer.com/tags/java/"},{"name":"考研机试","slug":"考研机试","permalink":"http://www.sillydeer.com/tags/考研机试/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://www.sillydeer.com/tags/贪心算法/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://www.sillydeer.com/tags/Dijkstra/"}]},{"title":"代理服务器","date":"2017-04-23T03:04:14.000Z","path":"2017/04/23/刷题-代理服务器/","text":"题目地址：牛客网-代理服务器 题目描述：使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。输入描述：每个测试数据包括 n + m + 2 行。第 1 行只包含一个整数 n，表示代理服务器的个数。第 2行至第n + 1行每行是一个字符串，表示代理服务器的 IP地址。这n个 IP地址两两不相同。第 n + 2 行只包含一个整数 m，表示要访问的服务器的个数。第 n + 3 行至第 n + m + 2 行每行是一个字符串，表示要访问的服务器的 IP 地址，按照访问的顺序给出。每个字符串都是合法的IP地址，形式为“xxx.yyy.zzz.www”，其中任何一部分均是0–255之间的整数。输入数据的任何一行都不包含空格字符。其中，1&lt;=n&lt;=1000，1&lt;=m&lt;=5000。 输出描述：可能有多组测试数据，对于每组输入数据， 输出数据只有一行，包含一个整数s，表示按照要求访问服务器的过程中切换代理服务器的最少次数。第一次使用的代理服务器不计入切换次数中。若没有符合要求的安排方式，则输出-1。 输入例子：3166.111.4.100162.105.131.113202.112.128.69672.14.235.104166.111.4.100207.46.19.190202.112.128.69162.105.131.113118.214.226.52 输出例子：1 解题思路：利用贪心算法。代理服务器可以多次使用，每次选择能够访问最多服务器的代理服务器，从需要转换代理服务器的位置开始，再次使用贪心算法，直到将服务器遍历完毕。 代码如下： import java.util.*; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); while (in.hasNext()){ int n = in.nextInt(); String[] arr1 = new String[n]; for(int i = 0; i &lt; n; i++){ arr1[i] = in.next(); } int m = in.nextInt(); String[] arr2 = new String[m]; for(int i = 0; i &lt; m; i++){ arr2[i] = in.next(); } int cur = 0; int result = 0; boolean flag = false; while (cur &lt; m){ int maxstep = cur; int j; for(int i = 0; i &lt; n; i++){ for(j = cur; j &lt; m; j++){ if(arr1[i].equals(arr2[j])){ if(j &gt; maxstep){ maxstep = j; } break; } } if(j == m){ flag = true; break; } } if(flag) break; if(cur == maxstep) break; cur = maxstep; result++; } if(flag){ System.out.println(result); }else { System.out.println(-1); } } } }","tags":[{"name":"java","slug":"java","permalink":"http://www.sillydeer.com/tags/java/"},{"name":"考研机试","slug":"考研机试","permalink":"http://www.sillydeer.com/tags/考研机试/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://www.sillydeer.com/tags/贪心算法/"}]},{"title":"Ubuntu 16.04+opencv-2.4.13+cuda-8.0环境配置","date":"2017-03-30T04:46:49.000Z","path":"2017/03/30/Ubuntu 16.04+opencv-2.4.13+cuda-8.0环境配置/","text":"环境准备首先安装Ubuntu16.04，参考Windows10+Ubuntu双系统安装。安装完成后，修改/etc/default/grub文件里的分辨率，并且把“quiet splash” 改成 “nomodeset quiet splash”, 然后 update-grub。插上Nvidia显卡，在附加驱动中安装合适的显卡驱动。 安装CUDA下载CUDA Toolkit1http://10.3.200.202/cache/4/01/nvidia.com/ff57ff0ed5693ec89f12a86f1a0987b4/cuda-repo-ubuntu1604-8-0-local-ga2_8.0.61-1_amd64.deb?autho=1490850739_f7a9f92a3edf953e01afae65e14a56d5&amp;file=cuda-repo-ubuntu1604-8-0-local-ga2_8.0.61-1_amd64.deb 下载完成之后使用如下命令进行安装123sudo dpkg -i cuda-repo-ubuntu1604-8-0-local-ga2_8.0.61-1_amd64.debsudo apt-get updatesudo apt-get install cuda 安装完成之后设置环境变量12export PATH=/usr/local/cuda-8.0/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH 查看显卡的驱动版本1cat /proc/driver/nvidia/version 查看nvcc编译器的版本1nvcc -V 安装OpenCV首先下载opencv2.4.13 安装依赖库12sudo apt-get update sudo apt-get install libopencv-dev build-essential checkinstall cmake pkg-config yasm libtiff5-dev libjpeg-dev libjasper-dev libavcodec-dev libavformat-dev libswscale-dev libdc1394-22-dev libxine2-dev libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev libv4l-dev python-dev python-numpy libtbb-dev libqt4-dev libgtk2.0-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libtheora-dev libvorbis-dev libxvidcore-dev x264 v4l-utils BUILD12345unzip 2.4.13cd opencv-2.4.13mkdir releasecd releasecmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_V4L=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D WITH_QT=ON -D WITH_OPENGL=ON -D ENABLE_FAST_MATH=1 -D CUDA_FAST_MATH=1 -D WITH_CUBLAS=1 -D BUILD_TIFF=ON -D WITH_CUDA=ON .. 检查cmake打印的信息中CUDA和CUDALS的状态是否是YES：12345678910-- Use Cuda: YES (ver 8.0) -- Use OpenCL: YES -- -- NVIDIA CUDA -- Use CUFFT: YES -- Use CUBLAS: YES -- USE NVCUVID: NO -- NVIDIA GPU arch: 11 12 13 20 21 30 35 -- NVIDIA PTX archs: 30 -- Use fast math: YES 确认无误后，开始安装12make -j4 //多线程编译sudo make install 配置环境变量1234echo &apos;/usr/local/lib&apos; | sudo tee -a /etc/ld.so.conf.d/opencv.conf sudo ldconfig printf &apos;# OpenCV\\nPKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig\\nexport PKG_CONFIG_PATH\\n&apos; &gt;&gt; ~/.bashrc source ~/.bashrc 查看opencv版本1pkg-config --modversion opencv 参考资料 UBUNTU 14.04: INSTALL OPENCV WITH CUDA","tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.sillydeer.com/tags/OpenCV/"},{"name":"CUDA","slug":"CUDA","permalink":"http://www.sillydeer.com/tags/CUDA/"}]},{"title":"SIFT视频特征分析","date":"2017-03-14T11:00:03.000Z","path":"2017/03/14/SIFT视频特征分析/","text":"SIFT算法SIFT（尺度不变特征变换， Scale‐Invariant Feature Transform）是在计算机视觉领域中检测和描述图像中局部特征的算法。SIFT特征具备旋转、缩放、平移等几何形变不变性，并且对噪声、光照等图像变化有很好的稳定性。SIFT算法分为以下几个阶段： 建立尺度空间应用高斯卷积核构造图像尺度空间（高斯卷积核是唯一可能的尺度空间核）：其中G(x, y, σ)是尺度可变高斯函数。σ是尺度空间因子，它决定着图像模糊平滑处理的程度。大尺度（σ值大）对应图像的概貌信息，小尺度（σ值小）对应图像的细节信息。大尺度对应着低分辨率，小尺度对应着高分辨率。利用不同尺度的高斯差分核与图像卷积构造高斯差分尺度空间（DoG scale-space）：图像金字塔的建立：将输入图像通过不同尺度（σ）的高斯核函数连续滤波和降采样，形成高斯金字塔图像，在此基础上建立DoG金字塔。如下图所示，左侧为高斯金字塔，右侧为DoG金字塔。高斯金字塔共分 O 组（ Octave），每组又分 S 层（ Layer）。金字塔的层数 S 为：S = s + 3。Lowe 建议 s 为 3。组内各层图像的分辨率是相同的，即长和宽相同，但尺度逐渐增加，即越往塔顶图像越模糊。而下一组的第0层图像是由上一组倒数第三层图像按照隔点降采样得到的，即图像的长和宽分别减半。DoG 金字塔是由高斯金字塔得到的，即高斯金字塔组内相邻两层图像相减得到 DoG 金字塔。因此高斯金字塔每组有 s+3 层图像，而 DoG 金字塔每组则有 s+2 层图像。 检测DOG尺度空间极值点为了寻找尺度空间的极值点，每个检测点不仅需要和它所在尺度空间图像的相邻点进行比较，还需要和它的相邻尺度空间图像的点进行比较。如下图所示。每个采样点和它同尺度的8个相邻点以及上下相邻尺度对应的9*2个点，共26个相邻点比较，以判断其是否为极值点。通过拟合三维二次函数以精确确定关键点的位置和尺度（达到亚像素精度），同时根据曲面拟合的方法对关键点进行进一步的精确定位，同时剔除对比度低的关键点和不稳定的边缘响应点（因为DoG算子会产生较强的边缘响应）。1.去除对比度低的点泰勒级数展开式为：对上式求导，并令其为0，得到精确的位置：将公式（2）代入公式（1），就得到了该极值点下的极值：若,该特征点就保留下来，否则就丢弃。 2.去除边缘响应一个平坦的DoG响应峰值往往在横跨边缘的地方有较大的主曲率，而在垂直边缘的方向上有较小的主曲率，主曲率可以通过2 × 2的Hessian矩阵H求出：矩阵 H 的直迹和行列式分别为：首先剔除掉那些行列式为负数的点，即Det(H) &lt; 0，因为如果像素的曲率有不同的符号，则该点肯定不是特征点。设α &gt; β，并且α = γ β，其中γ &gt; 1，则 (γ + 1)2 / γ的值在两个特征值相等的时候最小，随着γ的增大而增大。因此，为了检测主曲率是否在某域值γ下，只要检查下式是否成立即可： 对于不满足上式的极值点就不是特征点，因此应该把它们剔除掉。在Lowe的文章中取γ = 10。 为特征点分配方向经上面两个步骤，就可以找到图像中的所有特征点，这些特征点具有尺度不变性。为了实现旋转不变性，还需要为特征点分配一个方向角度。像素梯度的幅值和幅角的计算公式为：在完成特征点邻域范围内的梯度计算后，还要应用梯度方向直方图来统计邻域内像素的梯度方向所对应的幅值大小。在实际计算中，梯度直方图的范围是0~360度，其中每45度一个柱，总共8个柱。在以r为半径的区域内，把那些梯度方向在0~44度范围内的像素找出来，把它们的加权后的梯度幅值相加在一起，作为第一柱的柱高；求其它柱高度的方法相同。直方图的主峰值所代表的方向就是该特征点处邻域范围内图像梯度的主方向，也就是该特征点的主方向。每个特征点除了必须分配一个主方向外，还可能有一个或更多个辅方向，增加辅方向的目的是为了增强图像匹配的鲁棒性。辅方向的定义是，当存在另一个柱体高度大于主方向柱体高度的80%时，则该柱体所代表的方向角度就是该特征点的辅方向。 生成特征点描述符首先将坐标轴旋转为特征点的方向，以确保旋转不变性。图左部分的中央为当前特征点的位置，每个小格代表特征点邻域所在尺度空间的一个像素，利用公式求得每个像素的梯度幅值与梯度方向，箭头方向代表该像素的梯度方向，箭头长度代表梯度模值，然后用高斯窗口对其进行加权运算。图中蓝色的圈代表高斯加权的范围（越靠近特征点的像素梯度方向信息贡献越大）。然后在每4 × 4的小块上计算8个方向的梯度方向直方图，绘制每个梯度方向的累加值，就得到了一个子区域。Lowe建议对每个特征点使用4 × 4共16个子区域来描述，这样对于一个特征点就可以产生4 × 4 × 8 = 128个数据，即最终产生128维的SIFT特征向量。当两幅图像的SIFT特征向量生成后，下一步我们采用关键点特征向量的欧式距离来作为两幅图像中关键点的相似性判定度量。取图像1中的某个关键点，并找出其与图像2中欧式距离最近的前两个关键点，在这两个关键点中，如果最近的距离除以次近的距离少于某个比例阈值，则接受这一对匹配点。降低这个比例阈值，SIFT匹配点数目会减少，但更加稳定。 算法实现视频特征分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include \"opencv2/core/core.hpp\"#include \"opencv/highgui.h\"#include \"opencv2/imgproc/imgproc.hpp\"#include \"opencv2/features2d/features2d.hpp\"#include \"opencv2/nonfree/nonfree.hpp\"#include \"opencv2/legacy/legacy.hpp\"using namespace cv;using namespace std;int main(int argc, char** argv)&#123; VideoCapture vc; vc.open(0); Mat img = imread(\"test.png\", CV_LOAD_IMAGE_COLOR);//模版图像 namedWindow(\"SIFT\"); if (vc.isOpened()) &#123; while (1) &#123; Mat frame; //原始图像每5帧图像取1帧进行处理 for (int i = 0; i &lt; 5; i++) &#123; vc.read(frame); &#125; if (frame.empty()) &#123; break; &#125; SIFT sift1, sift2; vector&lt;KeyPoint&gt; key_points1, key_points2; Mat descriptors1, descriptors2, mascara; sift1(frame,mascara,key_points1,descriptors1); sift2(img,mascara,key_points2,descriptors2); //实例化暴力匹配器——BruteForceMatcher BruteForceMatcher&lt;L2&lt;float&gt; &gt; matcher; //定义匹配器算子 vector&lt;DMatch&gt;matches; //实现描述符之间的匹配，得到算子matches matcher.match(descriptors1,descriptors2,matches); //提取出前30个最佳匹配结果 nth_element(matches.begin(), //匹配器算子的初始位置 matches.begin()+29, // 排序的数量 matches.end()); // 结束位置 //剔除掉其余的匹配结果 matches.erase(matches.begin()+30, matches.end()); Mat img_matches; //在输出图像中绘制匹配结果 drawMatches(frame,key_points1, img, key_points2, matches, img_matches, Scalar(255,255,255)); imshow(\"SIFT\", img_matches); waitKey(1); &#125; &#125; vc.release(); return 0;&#125; 参考资料 SIFT特征提取分析 Opencv2.4.9源码分析——SIFT","tags":[{"name":"SIFT","slug":"SIFT","permalink":"http://www.sillydeer.com/tags/SIFT/"},{"name":"C++","slug":"C","permalink":"http://www.sillydeer.com/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.sillydeer.com/tags/OpenCV/"}]},{"title":"为博客添加多说评论框","date":"2017-03-14T10:33:50.000Z","path":"2017/03/14/为博客添加多说评论框/","text":"注册多说访问多说网站，选用自己习惯的社交工具帐号登录，登录后根据提示填写一些基本信息。完成所有步骤后，会生成一个通用代码，复制下来。 修改配置文件在_config.yml中增加duoshuo_shortname:站点的shortname，这里的shortname也就是你的二级域名。 粘贴通用代码打开themes/主题名/layout/_partial/comment.ejs这个文件 ，在下面位置粘贴刚才复制的代码：12345&lt;% if ( page.comments)&#123; %&gt;&lt;section id=\"comment\"&gt;此处粘贴通用代码&lt;/section&gt;&lt;% &#125; %&gt; 粘贴完后，替换代码里的标题、网址、ID三项信息。标题可以用&lt;%= item.title %&gt;来替换，网址可以用&lt;%- config.url %&gt;&lt;%- config.root%&gt;&lt;%- item.path %&gt;来替换,ID可以用&lt;%- item.path %&gt;来替换。 重新生成部署在hexo文件下执行：1$ hexo d -g","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.sillydeer.com/tags/hexo/"},{"name":"多说","slug":"多说","permalink":"http://www.sillydeer.com/tags/多说/"}]},{"title":"Hexo+Github Pages搭建个人博客","date":"2017-01-04T06:20:23.000Z","path":"2017/01/04/Hexo-Github-Pages搭建个人博客/","text":"系统环境配置安装Node.js下载Node.js，一路安装即可 安装Git下载Git 安装Hexo创建Hexo文件夹，进入文件夹，右键鼠标，点击Git Bash Here，执行以下操作：12345$ npm install hexo-cli -g$ hexo init$ npm install$ hexo g # hexo generate$ hexo s # hexo server 现在打开http://localhost:4000/，可以看到默认的效果了。 Hexo常用命令1234567$ hexo generate # 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹$ hexo server # 启动本地web服务，用于博客的预览$ hexo deploy # 部署博客到远端$ hexo new \"postName\" # 新建文章$ hexo new page \"pageName\" # 新建页面$ hexo d -g # 生成部署$ hexo s -g # 生成预览 将博客部署到Github Pages上本地的博客已经搭建起来了，我们现在需要将本地的博客部署到Github上，就可以直接通过http://gengxin1995.github.io来访问了。 1.创建项目代码库点击New repository 2.安装插件1$ npm install hexo-deployer-git --save 3.将本地Hexo文件更新到Github库中在配置文件_config.xml中作如下修改：1234deploy: type: git repository: https://github.com/gengxin1995/gengxin1995.github.io.git branch: master 然后在hexo文件下执行1$ hexo d -g 即可完成部署 绑定独立域名首先，你需要有个域名，学生可以参与腾讯云校园计划进入source目录，添加CNAME文件，内容为你的域名：在hexo文件夹中提交1$ hexo d -g 然后如下图所示解析域名等待生效，然后你就可以通过域名访问你的博客主页了。 Hexo主题设置以主题yilia为例进行说明在hexo文件夹下的themes目录下：1$ git clone https://github.com/litten/hexo-theme-yilia.git 修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。 返回hexo目录，在Git Bash中输入：12$ hexo clean$ hexo d -g 参考资料 我的博客是如何搭建的（github pages + HEXO + 域名绑定） 手把手教你使用Hexo + Github Pages搭建个人独立博客 Hexo主题Yilia","tags":[{"name":"Github","slug":"Github","permalink":"http://www.sillydeer.com/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.sillydeer.com/tags/Hexo/"}]}]